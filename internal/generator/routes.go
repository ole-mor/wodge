package generator

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"unicode"
)

// GenerateRoutes scans the routes directory and updates routes.generated.tsx
func GenerateRoutes(srcDir string) error {
	routesDir := filepath.Join(srcDir, "routes")

	var imports []string
	var routeObjects []string

	// Scan routes directory only (NOT api directory - API routes are not page routes)
	entries, err := os.ReadDir(routesDir)
	if err != nil {
		if !os.IsNotExist(err) {
			return err
		}
	} else {
		for _, entry := range entries {
			if entry.IsDir() {
				continue
			}
			name := entry.Name()
			if !strings.HasSuffix(name, ".route.tsx") {
				continue
			}

			// Parse route path from filename
			// home.route.tsx -> /
			// about.route.tsx -> /about
			// users.[id].route.tsx -> /users/:id (simplified logic for now)

			baseName := strings.TrimSuffix(name, ".route.tsx")
			componentName := toPascalCase(baseName)

			importLine := fmt.Sprintf("import %s from './routes/%s.route';", componentName, baseName)
			imports = append(imports, importLine)

			routePath := "/" + baseName
			if baseName == "home" || baseName == "index" {
				routePath = "/"
			}
			// TODO: Add support for dynamic routes based on [] syntax if needed later

			routeObj := fmt.Sprintf("  { path: '%s', element: <%s /> }", routePath, componentName)
			routeObjects = append(routeObjects, routeObj)
		}
	}

	output := fmt.Sprintf(`// This file is auto-generated by Wodge. Do not edit manually.
import React from 'react';
import { useRoutes } from 'react-router-dom';
%s

export const routes = [
%s
];

export function GeneratedRoutes() {
  return useRoutes(routes);
}
`, strings.Join(imports, "\n"), strings.Join(routeObjects, ",\n"))

	outFile := filepath.Join(srcDir, "routes.generated.tsx")
	return os.WriteFile(outFile, []byte(output), 0644)
}

func toPascalCase(s string) string {
	// Simple implementation: home -> Home, user_profile -> UserProfile
	parts := strings.FieldsFunc(s, func(r rune) bool {
		return !unicode.IsLetter(r) && !unicode.IsNumber(r)
	})
	var result string
	for _, part := range parts {
		if len(part) > 0 {
			runes := []rune(part)
			runes[0] = unicode.ToUpper(runes[0])
			result += string(runes)
		}
	}
	return result
}
